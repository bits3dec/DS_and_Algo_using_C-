#include<iostream>
#include<list>

#define NIL -1

using namespace std;

class Graph
{
    int v;
    list<int> *adj;
    void BridgesUtil(int u, bool visited[], int parent[], int low[], int disc[]);
    
    public:
    Graph(int v);
    void AddEdge(int u, int v);
    void Bridges();
};

Graph :: Graph(int v)
{
    this->v = v;
    adj = new list<int> [v];
}

void Graph :: AddEdge(int u, int v)
{
    adj[u].push_back(v);
    adj[v].push_back(u);
}

void Graph :: BridgesUtil(int u, bool visited[], int parent[], int low[], int disc[])
{
    static int time = 0;
    
    low[u] = disc[u] = time++;
    visited[u] = true;
    
    list<int> :: iterator i;
    for(i = adj[u].begin(); i != adj[u].end(); ++i)
    {
        int v = *i;
        
        if(visited[v] == false)
        {
            parent[v] = u;
            BridgesUtil(v, visited, parent, low, disc);
            
            low[u] = min(low[u], low[v]); // check if backedge exist from the subtree rooted with "v" to any ancestor of "u";
            
            if(low[v] > disc[u])
            {
                cout << u << " " << v << endl;
            }
        }
        else if(v != parent[u])
        {
            low[u] = min(low[u], disc[v]);
        }
    }
}

void Graph :: Bridges()
{
    int *parent = new int[v];
    int *low = new int[v];
    int *disc = new int[v];
    bool *visited = new bool[v];
    
    for(int i = 0; i < v; ++i)
    {
        parent[i] = NIL;
        visited[i] = false;
        low[i] = 0;
        disc[i] = 0;
    }
    
    for(int i = 0; i < v; ++i)
    {
        if(visited[i] == false)
            BridgesUtil(i, visited, parent, low, disc);
    }
}

int main() 
{ 
    // Create graphs given in above diagrams 
    cout << "\nBridges in first graph \n"; 
    Graph G1(5); 
    G1.AddEdge(1, 0); 
    G1.AddEdge(0, 2); 
    G1.AddEdge(2, 1); 
    G1.AddEdge(0, 3); 
    G1.AddEdge(3, 4); 
    G1.Bridges(); 
  
    cout << "\nBridges in second graph \n"; 
    Graph G2(4); 
    G2.AddEdge(0, 1); 
    G2.AddEdge(1, 2); 
    G2.AddEdge(2, 3); 
    G2.Bridges(); 
  
    cout << "\nBridges in third graph \n"; 
    Graph G3(7); 
    G3.AddEdge(0, 1); 
    G3.AddEdge(1, 2); 
    G3.AddEdge(2, 0); 
    G3.AddEdge(1, 3); 
    G3.AddEdge(1, 4); 
    G3.AddEdge(1, 6); 
    G3.AddEdge(3, 5); 
    G3.AddEdge(4, 5); 
    G3.Bridges(); 
  
    return 0; 
} 