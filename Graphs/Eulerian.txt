#include<iostream>
#include<list>

using namespace std;

class Graph
{
    int v;
    list<int> *adj;
    
    public:
    Graph(int v);
    void AddEdge(int u, int v);
    void DFS(int u, bool visited[]);
    bool IsConnected();
    int IsEulerian();
};

Graph :: Graph(int v)
{
    this->v = v;
    adj = new list<int>[v];
}

void Graph :: AddEdge(int u, int v)
{
    adj[u].push_back(v);
    adj[v].push_back(u);
}

void Graph :: DFS(int u, bool visited[])
{
     visited[u] = true;
     
     list<int> :: iterator i;
     for(i = adj[u].begin(); i != adj[u].end(); ++i)
     {
        if(visited[*i] == false)
            DFS(*i, visited); 
     }
}

bool Graph :: IsConnected() // Checks if all the non-zero degree vertices are connected
{
    bool *visited = new bool[v];
    int i;
    
    for(i = 0; i < v; ++i)
        visited[i] = false;
    
    for(i = 0; i < v; ++i)
    {
        if(adj[i].size() > 0) // get a non-zero degree vertex
            break;
    }
    
    if(i == v)
        return true; //all the vertices are zero degree vertex
        
    DFS(i, visited);
    
    for(int i = 0; i < v; ++i)
    {
        if(visited[i] == false && adj[i].size() > 0)  //checks if all non-zero vertices are visited in the DFS traversal for it to be Eularian path/cycle
            return false;
    }
    
    return true;
}

int Graph :: IsEulerian()
{
    if(IsConnected() == false)
        return 0;
    
    int odd = 0;
    
    for(int i = 0; i < v; ++i)
    {
        if(adj[i].size() % 2 == 1)
            odd++;
            
        if(odd > 2)
            break;
    }
    
    if(odd == 0)
        return 1; // Eularian cycle: Graph is Eularian
    if(odd == 2)
        return 2; //Eularian path: Graph is Semi-Eularian
    
    return 0; // No Eularian
}

void Test(Graph &g) 
{ 
    int res = g.IsEulerian(); 
    if (res == 0) 
        cout << "graph is not Eulerian\n"; 
    else if (res == 1) 
        cout << "graph has a Euler cycle\n"; 
    else
        cout << "graph has a Euler path\n"; 
} 
  
// Driver program to test above function 
int main() 
{ 
    // Let us create and test graphs shown in above figures 
    Graph G1(5); 
    G1.AddEdge(1, 0); 
    G1.AddEdge(0, 2); 
    G1.AddEdge(2, 1); 
    G1.AddEdge(0, 3); 
    G1.AddEdge(3, 4); 
    Test(G1); 
  
    Graph G2(5); 
    G2.AddEdge(1, 0); 
    G2.AddEdge(0, 2); 
    G2.AddEdge(2, 1); 
    G2.AddEdge(0, 3); 
    G2.AddEdge(3, 4); 
    G2.AddEdge(4, 0); 
    Test(G2); 
  
    Graph G3(5); 
    G3.AddEdge(1, 0); 
    G3.AddEdge(0, 2); 
    G3.AddEdge(2, 1); 
    G3.AddEdge(0, 3); 
    G3.AddEdge(3, 4); 
    G3.AddEdge(1, 3); 
    Test(G3); 
  
    // Let us create a graph with 3 vertices 
    // connected in the form of cycle 
    Graph G4(3); 
    G4.AddEdge(0, 1); 
    G4.AddEdge(1, 2); 
    G4.AddEdge(2, 0); 
    Test(G4); 
  
    // Let us create a graph with all veritces 
    // with zero degree 
    Graph G5(3); 
    Test(G5); 
  
    return 0; 
} 

