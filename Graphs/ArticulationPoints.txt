#include<iostream>
#include<list>

#define NIL -1

using namespace std;

class Graph
{
    int v;
    list<int> *adj;
    void ArticulationPointUtil(int u, int parent[], int low[], int disc[], bool visited[], bool aPoints[]);
    
    public:
    Graph(int v);
    void AddEdge(int u, int v);
    void ArticulationPoint();
};

Graph :: Graph(int v)
{
    this->v = v;
    adj = new list<int> [v];
}

void Graph :: AddEdge(int u, int v)
{
    adj[u].push_back(v);
    adj[v].push_back(u);
}

void Graph :: ArticulationPointUtil(int u, int parent[], int low[], int disc[], bool visited[], bool aPoints[])
{
    static int time = 0;
    int children = 0;
    
    low[u] = disc[u] = time++;
    visited[u] = true;

    list<int> :: iterator i;
    for(i = adj[u].begin(); i != adj[u].end(); ++i)
    {
        int v = *i;
        
        if(visited[v] == false)
        {
            parent[v] = u;
            children++;
            ArticulationPointUtil(v, parent, low, disc, visited, aPoints);
            
            low[u] = min(low[u], low[v]);  // check if backedge exist from the subtree rooted with "v" to "u" or any ancestor of "u";
        
            if(parent[u] == NIL && children >= 2)
            {
                aPoints[u] = true;
            }
            else if(parent[u] != NIL && low[v] >= disc[u])
            {
                aPoints[u] = true;
            }
        }
        else if(v != parent[u])
        {
            low[u] = min(low[u], disc[v]);
        }
    }
}

void Graph :: ArticulationPoint()
{
    int *parent = new int[v];
    int *low = new int[v];
    int *disc = new int[v];
    
    bool *visited = new bool[v];
    bool *aPoints = new bool[v];
    
    for(int i = 0; i < v; ++i)
    {
        parent[i] = NIL;
        low[i] = 0;
        disc[i] = 0;
        visited[i] = false;
        aPoints[i] = false;
    }
    
    for(int i = 0; i < v; ++i)
    {
        if(visited[i] == false)
            ArticulationPointUtil(i, parent, low, disc, visited, aPoints);   
    }

    for (int i = 0; i < v; i++) 
        if (aPoints[i] == true) 
            cout << i << " "; 
} 
  
// Driver program to test above function 
int main() 
{ 
    // Create graphs given in above diagrams 
    cout << "\nArticulation points in first graph \n"; 
    Graph G1(5); 
    G1.AddEdge(1, 0); 
    G1.AddEdge(0, 2); 
    G1.AddEdge(2, 1); 
    G1.AddEdge(0, 3); 
    G1.AddEdge(3, 4); 
    G1.ArticulationPoint(); 
  
    cout << "\nArticulation points in second graph \n"; 
    Graph G2(4); 
    G2.AddEdge(0, 1); 
    G2.AddEdge(1, 2); 
    G2.AddEdge(2, 3); 
    G2.ArticulationPoint(); 
  
    cout << "\nArticulation points in third graph \n"; 
    Graph G3(7); 
    G3.AddEdge(0, 1); 
    G3.AddEdge(1, 2); 
    G3.AddEdge(2, 0); 
    G3.AddEdge(1, 3); 
    G3.AddEdge(1, 4); 
    G3.AddEdge(1, 6); 
    G3.AddEdge(3, 5); 
    G3.AddEdge(4, 5); 
    G3.ArticulationPoint(); 
  
    return 0; 
} 