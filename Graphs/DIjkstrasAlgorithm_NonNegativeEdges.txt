#include<iostream>
#include<list>
#include<queue>
#include<limits.h>

#define N 5

using namespace std;

class Graph
{
    int v;
    list<int> *adj;
    void updatePriority_queue(priority_queue<int, vector<int>, greater<int>> &pq, int oldValue, int newValue);
    void printResult(int s, int path[N], int distance[N]);
    
    public:
    Graph (int v);
    void AddEdge(int u, int v);
    void DijkstrasAlgorithm(int s, int weight[N][N]);
};

Graph :: Graph (int v)
{
    this->v = v;
    adj = new list<int> [v];
}

void Graph :: AddEdge(int u, int v)
{
    adj[u].push_back(v);
}

void Graph :: DijkstrasAlgorithm(int s, int weight[N][N])
{
    priority_queue<int, vector<int>, greater<int>> pq;
    
    int *distance = new int[v];
    int *path = new int[v];
    
    for(int i = 0; i < v; ++i)
    {
        distance[i] = INT_MAX;
        path[i] = -1;
    }
    
    pq.push(s);
    distance[s] = 0;
    path[s] = s;
    
    while(pq.empty() == false)
    {
        int u = pq.top();  //priorit_queue DeleteMin()
        pq.pop();
        
        list<int> :: iterator i;
        for(i = adj[u].begin(); i != adj[u].end(); ++i)
        {
            int v = *i;
            int newDistance = distance[u] + weight[u][v];
            
            if(path[v] == -1) // visiting "v" first time
            {
                distance[v] = newDistance;
                path[v] = u;
                pq.push(v);  
            }
            if(newDistance < distance[v]) // processing "v" an already visited node
            {
                distance[v] = newDistance;
                path[v] = u;
                updatePriority_queue(pq, v, newDistance); //update the priority of "v" i.e. distance in the priority queue
            }
        }
    }
    
    printResult(s, path, distance);
}

void Graph :: updatePriority_queue(priority_queue<int, vector<int>, greater<int>> &pq, int oldValue, int newValue)
{
    priority_queue<int, vector<int>, greater<int>> temp_pq;
    
    while(pq.empty() == false)
    {
        int currentValue = pq.top();
        pq.pop();
        
        if(currentValue == oldValue)
            temp_pq.push(newValue);
        else
            temp_pq.push(currentValue);
    }
    
    pq = temp_pq;
}

void Graph :: printResult(int s, int path[N], int distance[N])
{
    cout<< "The shortest path from source " << s << " is : \n";
    for(int i = 0; i < 5; ++i)
    {
        if(path[i] == -1)
        {
            cout << "Node: "<< i <<" Node "<< s << " doesnot have a path to Node "<< i << endl;
            continue;  
        }
        cout<< "Node: "<< i<< " ";
        cout<< "Path: "<< path[i] << " ";
        cout<< "Distance: "<< distance[i]<< endl;
    }
        
}

int main()
{
    Graph G(5);
    G.AddEdge(0,1);
    G.AddEdge(0,2);
    G.AddEdge(1,2);
    G.AddEdge(1,3);
    G.AddEdge(1,4);
    G.AddEdge(3,2);
    G.AddEdge(3,1);
    G.AddEdge(4,3);
    
    int weight[N][N] = { {0, 1, 4, 0, 0},
                         {0, 0, 3, 2, 2},
                         {0, 0, 0, 0, 0},
                         {0, 1, 5, 0, 0},
                         {0, 0, 0, 3, 0}
                       };
    
    G.DijkstrasAlgorithm(0, weight);
    
    return 0;
}