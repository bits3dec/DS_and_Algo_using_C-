#include<iostream>
#include<list>

using namespace std;

class Graph
{
    int V, E;
    list<int> *adj;
    bool isReachableUtil(bool visited[], int s, int d);
    
    public:
    Graph(int v, int e);
    void addEdge(int u, int v);
    bool isReachable(int s, int d);
};

Graph :: Graph(int v, int e)
{
    V = v;
    E = e;
    adj = new list<int> [V];
}

void Graph :: addEdge(int u, int v)
{
    adj[u].push_back(v);
}

bool Graph :: isReachableUtil(bool visited[], int s, int d)
{
    if(s == d) 
        return true;
        
    visited[s] = true;
    
    list<int> :: iterator i;
    
    for(i = adj[s].begin(); i != adj[s].end(); ++i)
    {
        int v = *i;
        
        if(visited[v] == false && isReachableUtil(visited, v, d) == true)
            return true;
    }
    return false;
}

bool Graph :: isReachable(int u, int v)
{
    bool *visited = new bool [v];
    
    for(int i = 0; i < v; ++i)
        visited[i] = false;
        
    if(isReachableUtil(visited, u, v)) 
        cout<< "\n There is a path from " << u << " to " << v; 
    else
        cout<< "\n There is no path from " << u << " to " << v;
}
// Driver program to test methods of graph class 
int main() 
{ 
    // Create a graph given in the above diagram 
    Graph g(4, 6); 
    g.addEdge(0, 1); 
    g.addEdge(0, 2); 
    g.addEdge(1, 2); 
    g.addEdge(2, 0); 
    g.addEdge(2, 3); 
    g.addEdge(3, 3); 
  
    int u = 1, v = 3;
    bool *visited = new bool [v];
    
    g.isReachable(1,3);
    g.isReachable(3,1);
    g.isReachable(0,2);
    g.isReachable(2,0);
  
    return 0; 
} 
